<?php
/* HackThisSite IRC CVE Announcer
    - Version 1.0

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.  This license
    MUST remain with all distributions of this program.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
require __DIR__ . '/vendor/autoload.php';

define('BASE_DIR', dirname(__FILE__).DIRECTORY_SEPARATOR);
define('LIB_DIR', BASE_DIR.'lib'.DIRECTORY_SEPARATOR);

require_once(LIB_DIR.'protoirc.php');

$config = @parse_ini_file(BASE_DIR.'config.ini', true);
if ($config === FALSE) {
  echo "Error: Cannot read config.ini\n";
  exit(1);
}

// Signal catchers
declare(ticks = 1);
pcntl_signal(SIGTERM, "signal");
pcntl_signal(SIGINT, "signal");
pcntl_signal(SIGHUP, "signal");
function signal($signal) {
  global $irc, $config;
  if ($config['global']['daemon']) {
    toLog('Received signal ('.$signal."), shutting down...\n");
  } else {
    $irc->stdout("{$irc->ansi->_black}[{$irc->ansi->_red}ALERT{$irc->ansi->_black}] Received signal: {$signal}\n");
  }
  $irc->send('QUIT Received signal '.$signal);
  $irc->close();
  exit;
}

if ($config['global']['daemon']) toLog('Daemon started.  Establishing event handlers ...');

// Establish connection settings and actions
$ircuri = ($config['irc']['ssl']?'ssl':'irc').'://'.$config['irc']['nick'].':'.$config['irc']['pass'].'@'.$config['irc']['server'].':'.$config['irc']['port'].'/'.str_replace('#','',$config['irc']['channels']);
$irc = new ProtoIRC($ircuri, function ($irc) {});
$start_time = time();

// CVE list will reside in-memory here
$cvedb = array();

// Set admin names to lowercase for easier matching
array_walk($config['irc']['admins'], 'lcAdmins');

//### Admin Commands
// - Quit
$irc->in('/^:(.*) PRIVMSG (.*) :!quit/i', function ($irc, $nick, $channel) use (&$config) {
  if (in_array(strtolower($nick), $config['irc']['admins'])) {
    preg_match('/(.*)!.*/', $nick, $nickShort);
    $recipient = (strtolower($channel) == strtolower($irc->nick) ? $nickShort[1] : $channel);
    $irc->send($recipient, 'Bye!');
    $irc->quit('Shutting down...');
    $irc->close();
    exit;
  }
});
// - Config rehash
$irc->in('/^:(.*) PRIVMSG (.*) :!rehash/i', function ($irc, $nick, $channel) use (&$config) {
  if (in_array(strtolower($nick), $config['irc']['admins'])) {
    preg_match('/(.*)!.*/', $nick, $nickShort);
    $config = @parse_ini_file(BASE_DIR.'config.ini', true);
    $recipient = (strtolower($channel) == strtolower($irc->nick) ? $nickShort[1] : $channel);
    if ($config === FALSE) {
      $irc->send($recipient, 'Error reading config, bailing!');
      exit(1);
    }
    $irc->send($recipient, 'Configuration rehashed');
  }
});

// CTCP messages
$irc->in('/^:(.*) PRIVMSG (.*) :\x01(.+)\x01$/i', function ($irc, $nick, $myself, $ctcp) use (&$config) {
  if (strtolower($myself) != strtolower($irc->nick)) return;
  preg_match('/(.*)!.*/', $nick, $nickShort);
  switch (strtolower($ctcp)) {
    case 'time':
      $irc->notice($nickShort[1].' :TIME '.gmdate('r'));
      break;
    case 'version':
      $irc->notice($nickShort[1].' :VERSION CVE IRC Announcer - https://www.github.com/HackThisCode/CVE-Bot');
      break;
  }
});

// RAW 376: MOTD end
//   Initialize in-memory CVE list so we start from somewhere
$irc->in('/^:.* 376 .*/', function ($irc) use (&$config) {
  $irc->async(function ($irc) use (&$config) {
    process_cves(fetch_rss($config['cve']['feedurl']));
  });
});

$irc->timer($config['cve']['delay'], function ($irc) use (&$config) {
  global $start_time;
  if (time() - $start_time < 5) return; // Delay a little until things spin up
  $newcves = process_cves(fetch_rss($config['cve']['feedurl']));
  $cnt = 0;
  foreach ($newcves as $cve => $data) {
    $cnt++;
    if ($cnt > $config['cve']['max_new']) break;
    $announcement  = '['.$cve.'] ('.date('M j Y H:i:s', $data['timestamp']);
    if (count($data['tags']) > 0) $announcement .= ' - '.implode(', ', $data['tags']);
    $announcement .= ') '.$data['url'].' -- ';
    $announcement .= (strlen($data['desc']) > 250 ? substr($data['desc'], 0, 250).' ...' : $data['desc']);
//    $irc->send($irc->channels, $announcement);
    $irc->send(explode(',', $config['irc']['channels']), $announcement);
    sleep(1);
  }
});

// Catch-all: Print raw line to terminal for debugging/hacking
$irc->in('/(.*)/', function ($irc, $line) use (&$config) {
  if ($config['global']['daemon']) {
    toLog($line);
  } else {
    $irc->stdout("<< {$line}\n", '_black');
  }
});

if ($config['global']['daemon']) toLog("Connecting ...\n");

// Everything bound.  Proceed.
$irc->go($config['global']['daemon']);


function process_cves($rss_array) {
  global $cvedb;
  if (!is_array($rss_array)) return;
  // Iterate through CVE feed
  $newcves = array();
  foreach ($rss_array as $cve) {
    preg_match('#(CVE\-\d+\-\d+)(?:\s*\(([^\)]+)\))?#', trim($cve['title']), $matches);
    $cve_name = $matches[1];
    $cve_tags = ($matches[2] ? preg_split('/\s*,\s*/', $matches[2]) : array());
    $cve_timestamp = strtotime($cve['dc']['date']);
    if (!array_key_exists($cve_name, $cvedb) || $cve_timestamp > $cvedb[$cve_name]['timestamp']) {
      $cvedb[$cve_name] = array(
	'timestamp'	=> $cve_timestamp,
	'url'		=> $cve['link'],
	'tags'		=> $cve_tags,
	'desc'		=> str_replace("\n", '', $cve['description']),
      );
      $newcves[$cve_name] = $cvedb[$cve_name];
    }
  }
  // Flush CVEs from memory older than 8 days (NIST maximum for RSS feed)
  foreach ($cvedb as $cve => $data) {
    if ((time()-$data['timestamp']) >= 691200) {
      unset($cvedb[$cve]);
    }
  }
  return $newcves;
}

function fetch_rss($url) {
  $feed = '';
  $iter = 0;
  while (!$feed && $iter < 5) {
    $iter++;
/* Commented out because some systems don't have curl.so
    $ch = curl_init();
    curl_setopt($ch, CURLOPT_URL, $url);
    curl_setopt($ch, CURLOPT_HEADER, 0);
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
    curl_setopt($ch, CURLOPT_TIMEOUT, 5);
    $feed = curl_exec($ch);
    curl_close($ch);
*/
    $feed = @file_get_contents($url);
    if (!$feed) sleep(60);
  }
  if ($feed) {
    toLog('RSS feed fetched after '.$iter.' attempts');
  } else {
    toLog('Failed to fetch RSS feed');
    return;
  }
  $rss = new MagpieRSS($feed);
  if ($rss === false) return;
  return $rss->items;
}

function lcAdmins($val, $key) {
  global $config;
  $config['irc']['admins'][$key] = strtolower($val);
}

function toLog($line) {
  global $config;
  return file_put_contents($config['global']['log'], '['.date('m/d/y H:i:s').'] '.$line."\n", FILE_APPEND);
}

// EOF
